<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Previsão do Tempo</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0; /* Removido padding para maximizar espaço */
            background-color: #111; /* Fundo escuro para TVs */
            color: #f0f0f0;      /* Texto claro */
            height: 100vh;       /* Ocupar toda a altura da viewport */
            width: 100vw;        /* Ocupar toda a largura da viewport */
            overflow: hidden;    /* IMPEDE barras de rolagem no body */
            display: flex;
            flex-direction: column;
            align-items: center; /* Centraliza o .weather-container horizontalmente */
            justify-content: flex-start; /* Alinha ao topo, mas pode ajustar se precisar */
            padding-top: 15px; /* Um pequeno espaço no topo */
            box-sizing: border-box;
        }
        
        .weather-container {
            background-color: #222;
            padding: 15px; /* Reduzido um pouco */
            border-radius: 8px;
            width: 90%; /* Usar uma porcentagem maior da largura */
            max-width: 1000px; /* Limite máximo para telas muito grandes */
            display: flex;
            flex-direction: column; /* Itens empilhados verticalmente */
            /* Vamos deixar a altura ser determinada pelo conteúdo,
               mas o body com 100vh e overflow:hidden vai cortar o que não couber */
            box-shadow: 0 0 15px rgba(0,0,0,0.6); /* Sombra um pouco mais pronunciada */
        }
        
        h1#location-name { /* Adicionando ID para ser mais específico */
            text-align: center;
            color: #00aaff;
            font-size: 2.2em; /* Ajuste conforme o visual na TV */
            margin-top: 0;
            margin-bottom: 10px;
        }
        
        /* Novo: Contêiner específico para o gráfico para controlar seu tamanho */
        .chart-container {
            position: relative; /* Necessário para Chart.js responsive */
            width: 100%;      /* Ocupar toda a largura do .weather-container */
            /* Defina uma altura proporcional ou máxima para o gráfico.
               Experimente com vh (viewport height) ou % da altura do .weather-container se ele tiver altura definida.
               Por exemplo, 60% da altura visível da tela: */
            height: 60vh; /* <<<< AJUSTE ESTE VALOR CONFORME NECESSÁRIO >>>> */
                          /* Se o texto abaixo for removido, pode aumentar aqui */
            max-height: 400px; /* Um limite máximo para não ficar gigante */
        }
        
        #forecast-text {
            text-align: center;
            margin-top: 10px; /* Reduzido */
            font-size: 0.9em; /* Pode reduzir mais se precisar de espaço */
            /* Se for remover, pode deletar este bloco CSS */
        }
        
        #forecast-text div {
            margin-bottom: 3px; /* Reduzido */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px; /* Espaço entre os itens */
        }
        
        #forecast-text img {
            width: 25px; /* Reduzido */
            height: 25px;
            /* margin: 0 5px; Removido, usando gap no pai */
        }
    </style>
</head>
<body>
    <div class="weather-container">
        <h1 id="location-name">Previsão do Tempo</h1>
        <canvas id="weatherChart" width="400" height="200"></canvas>
        <div id="forecast-text">
            <!-- Previsão textual será inserida aqui -->
        </div>
    </div>

    <script>
        // --- CONFIGURAÇÕES ---
        const API_KEY = '90f67f01d5b8618ca6fa64716d5240ed'; // IMPORTANTE: Substitua pela sua chave!
        const CITY_NAME = 'Tatui,BR'; // Ex: 'Londrina,BR', 'Curitiba,BR' (Cidade, Código do País)
        // Ou por coordenadas: const LAT = -23.5505; const LON = -46.6333;
        const PROXY_URL = 'https://api.allorigins.win/raw?url='; // Ou outro, se necessário
        const REFRESH_INTERVAL_HOURS = 3; // Atualizar a cada 2 horas
        // --- FIM ---

        const forecastTextElement = document.getElementById('forecast-text');
        const locationNameElement = document.getElementById('location-name');
        let weatherChart = null; // Variável para guardar a instância do gráfico

        function getApiUrl() {
            // Se usar LAT e LON:
            // return `https://api.openweathermap.org/data/2.5/forecast?lat=${LAT}&lon=${LON}&appid=${API_KEY}&units=metric&lang=pt_br`;
            return `https://api.openweathermap.org/data/2.5/forecast?q=${CITY_NAME}&appid=${API_KEY}&units=metric&lang=pt_br`;
        }

        async function fetchWeatherData() {
            locationNameElement.textContent = `Previsão para ${CITY_NAME.split(',')[0]}`;
            const apiUrl = getApiUrl();
            const urlToFetch = PROXY_URL + encodeURIComponent(apiUrl); // Se precisar do proxy
            // const urlToFetch = apiUrl; // Se a API OpenWeatherMap permitir chamadas diretas CORS (teste!)

            console.log("Buscando dados de:", urlToFetch);
            try {
                const response = await fetch(urlToFetch);
                if (!response.ok) {
                    throw new Error(`Erro de rede: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                console.log("Dados recebidos:", data);

                if (data.cod && data.cod !== "200") {
                     throw new Error(`Erro da API: ${data.message || 'Erro desconhecido'}`);
                }

                processAndDisplayData(data);
            } catch (error) {
                console.error("Falha ao buscar dados do tempo:", error);
                forecastTextElement.innerHTML = `<p style="color:red;">Erro ao carregar previsão: ${error.message}</p>`;
            }
        }

        function processAndDisplayData(data) {
            if (!data || !data.list || data.list.length === 0) {
                forecastTextElement.innerHTML = "<p>Dados de previsão não disponíveis.</p>";
                return;
            }

            const dailyData = {}; // Objeto para agrupar dados por dia

            data.list.forEach(item => {
                const date = item.dt_txt.split(' ')[0]; // Pega apenas a parte da data YYYY-MM-DD
                if (!dailyData[date]) {
                    dailyData[date] = {
                        temps: [],
                        weather_descriptions: [],
                        icons: [],
                        humidity: [],
                        wind_speed: []
                    };
                }
                dailyData[date].temps.push(item.main.temp);
                dailyData[date].weather_descriptions.push(item.weather[0].description);
                dailyData[date].icons.push(item.weather[0].icon);
                dailyData[date].humidity.push(item.main.humidity);
                dailyData[date].wind_speed.push(item.wind.speed);
            });

            const labels = [];
            const minTemps = [];
            const maxTemps = [];
            let textForecastHTML = "";

            // Pegar os próximos 5 dias (ou menos se a API não retornar tudo)
            const forecastDays = Object.keys(dailyData).sort().slice(0, 5);

            forecastDays.forEach(date => {
                const dayInfo = dailyData[date];
                const dayMinTemp = Math.min(...dayInfo.temps);
                const dayMaxTemp = Math.max(...dayInfo.temps);
                
                // Formatar data para exibição (ex: Dia 27/05)
                const dateParts = date.split('-');
                const displayDate = `${dateParts[2]}/${dateParts[1]}`;
                labels.push(displayDate);
                minTemps.push(dayMinTemp.toFixed(1)); // Arredonda para 1 casa decimal
                maxTemps.push(dayMaxTemp.toFixed(1));

                // Pega a descrição e ícone mais representativos do dia (ex: o do meio-dia)
                const midDayIndex = Math.floor(dayInfo.weather_descriptions.length / 2);
                const description = dayInfo.weather_descriptions[midDayIndex];
                const icon = dayInfo.icons[midDayIndex];

                textForecastHTML += `
                    <div>
                        <strong>${displayDate}:</strong> Min: ${dayMinTemp.toFixed(1)}°C, Max: ${dayMaxTemp.toFixed(1)}°C
                        <img src="https://openweathermap.org/img/wn/${icon}.png" alt="${description}" title="${description}">
                        (${description})
                    </div>`;
            });

            forecastTextElement.innerHTML = textForecastHTML;
            renderWeatherChart(labels, minTemps, maxTemps);
        }

        function renderWeatherChart(labels, minData, maxData) {
            const ctx = document.getElementById('weatherChart').getContext('2d');
            
            if (weatherChart) {
                weatherChart.destroy(); // Destrói o gráfico anterior para redesenhar
            }

            weatherChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Temp. Mínima (°C)',
                            data: minData,
                            borderColor: 'blue',
                            backgroundColor: 'rgba(0, 0, 255, 0.1)',
                            fill: false,
                            tension: 0.1
                        },
                        {
                            label: 'Temp. Máxima (°C)',
                            data: maxData,
                            borderColor: 'red',
                            backgroundColor: 'rgba(255, 0, 0, 0.1)',
                            fill: false,
                            tension: 0.1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // Mude para false se quiser controlar com CSS
                    scales: {
                        x: {
                            grid: {
                                display: false // Remove linhas de grade verticais
                            },
                            ticks: {
                                color: '#ccc', // Cor dos rótulos do eixo X
                                font: {
                                    size: 10 // Fonte menor para os dias
                                }
                            }
                        },
                        y: {
                            grid: {
                                // display: false, // Descomente para remover linhas de grade horizontais
                                color: 'rgba(204, 204, 204, 0.15)' // Linhas de grade horizontais mais fracas
                            },
                            beginAtZero: false, // Não precisa começar em zero para temperatura
                            ticks: {
                                color: '#ccc', // Cor dos rótulos do eixo Y
                                stepSize: 5,   // Define o intervalo entre os ticks (ex: 5°C) - ajuste conforme sua faixa de temp.
                                font: {
                                    size: 10 // Fonte menor para as temperaturas
                                },
                                callback: function(value) {
                                    return value + '°C';
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: '#ddd', // Cor do texto da legenda
                                font: {
                                    size: 12 // Tamanho da fonte da legenda
                                },
                                boxWidth: 20, // Largura da caixa de cor da legenda
                                padding: 10   // Espaçamento da legenda
                            }
                        },
                        title: {
                            display: true,
                            text: 'Próximos 5 Dias', // Pode ser mais curto ou removido se o H1 já diz
                            color: '#eee',
                            font: {
                                size: 16 // Tamanho do título do gráfico
                            },
                            padding: {
                                bottom: 10 // Espaço abaixo do título do gráfico
                            }
                        },
                        tooltip: { // Tooltips não são muito úteis na TV
                            enabled: false // Desabilita tooltips ao passar o mouse
                        }
                    },
                    elements: {
                        point: {
                            radius: 2, // Raio dos pontos nos dados (0 para esconder)
                            hoverRadius: 4
                        },
                        line: {
                            borderWidth: 2, // Espessura das linhas
                            tension: 0.1    // Curvatura das linhas (0 = retas)
                        }
                    }
                }
            });
        }

        // Carregar dados ao iniciar e definir intervalo
        fetchWeatherData();
        setInterval(fetchWeatherData, REFRESH_INTERVAL_HOURS * 60 * 60 * 1000);
    </script>
</body>
</html>
